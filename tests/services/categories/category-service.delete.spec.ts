import { faker } from '@faker-js/faker';
import Category from '../../../app/db/models/Categories.ts';
import Product from '../../../app/db/models/Products.ts';
import categoryService from '../../../app/services/categories/CategoryService.ts';
import { CategoryError } from '../../../app/services/errors/CategoryErrors.ts';
import { setupCategoryTestSuite } from './category-test-utils.ts';

describe('CategoryService - Delete Operations', () => {
  const { setCategoryTestData } = setupCategoryTestSuite();

  describe('categoryService.deleteCategory', () => {
    it('should soft delete a category', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;
      
      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await categoryService.createCategory({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      await categoryService.deleteCategory(category._id!.toString());
      const categories = await categoryService.getCategories({ level: 1 });
      const deletedCategoryExists = categories.data.some((cat) => cat._id?.toString() === category._id?.toString());
      expect(deletedCategoryExists).toBe(false);

      const deletedCategory = await Category.findById(category._id);
      expect(deletedCategory).toBeDefined();
      expect(deletedCategory?.deletedAt).toBeDefined();
      expect(deletedCategory?.deletedAt).toBeInstanceOf(Date);

      setCategoryTestData({
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
      });
    });

    it('should prevent deletion of category with subcategories', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;
      const subcategoryName = `${faker.commerce.product()} Subcategory`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await categoryService.createCategory({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      const subcategory = await categoryService.createCategory({
        name: subcategoryName,
        description: `${subcategoryName} generated by faker for testing`,
        level: 2,
        parentId: category._id!.toString(),
        sortOrder: 1,
      });

      await expect(categoryService.deleteCategory(category._id!.toString()))
        .rejects.toThrow('Cannot delete category with subcategories');

      setCategoryTestData({
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: subcategory._id!.toString(),
      });
    });

    it('should prevent deletion of category with products', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await categoryService.createCategory({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      const product = await Product.create({
        title: faker.commerce.productName(),
        description: faker.commerce.productDescription(),
        shortDescription: faker.commerce.productAdjective(),
        price: parseFloat(faker.commerce.price()),
        categories: [category._id],
        images: [],
        isPublished: true,
      });

      await expect(categoryService.deleteCategory(category._id!.toString()))
        .rejects.toThrow('Cannot delete category. 1 products are using this category.');

      await Product.deleteOne({ _id: product._id });

      setCategoryTestData({
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
      });
    });

    it('should throw error for invalid category ID', async () => {
      await expect(categoryService.deleteCategory('invalid-id')).rejects.toThrow(CategoryError);
      await expect(categoryService.deleteCategory('507f1f77bcf86cd799439011')).rejects.toThrow(CategoryError);
    });
  });
});