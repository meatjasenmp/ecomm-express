import { faker } from '@faker-js/faker';
import Category from '../../../app/db/models/Categories.ts';
import categoryService from '../../../app/services/categories/CategoryService.ts';
import { setupCategoryTestSuite } from './category-test-utils.ts';

describe('CategoryService - Validation Operations', () => {
  const { setCategoryTestData } = setupCategoryTestSuite();

  describe('categoryService.validateCategoryHierarchy', () => {
    it('should validate correct hierarchy', async () => {
      const brandName = `${faker.company.name()} Brand`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const validCategoryName = `${faker.commerce.productName()} Valid Category`;
      const result = await categoryService.validateCategoryHierarchy({
        name: validCategoryName,
        level: 1,
        parentId: brand._id!.toString(),
      });

      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);

      setCategoryTestData({
        brandId: brand._id!.toString(),
      });
    });

    it('should reject invalid hierarchy', async () => {
      const brandName = `${faker.company.name()} Brand`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const invalidCategoryName = `${faker.commerce.productName()} Invalid Category`;
      const result = await categoryService.validateCategoryHierarchy({
        name: invalidCategoryName,
        level: 2,
        parentId: brand._id!.toString(),
      });


      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors[0]).toContain('Parent level (0) must be exactly one level below child level (2)');

      setCategoryTestData({
        brandId: brand._id!.toString(),
      });
    });

    it('should validate level constraints', async () => {
      const testCases: Array<{ level: number; parentId: string | null; shouldBeValid: boolean }> = [
        { level: -1, parentId: null, shouldBeValid: false },
        { level: 3, parentId: null, shouldBeValid: false },
        { level: 0, parentId: 'some-id', shouldBeValid: false },
        { level: 1, parentId: null, shouldBeValid: false },
      ];

      for (const testCase of testCases) {
        const categoryName = `${faker.commerce.productName()} Test Category`;
        const result = await categoryService.validateCategoryHierarchy({
          name: categoryName,
          level: testCase.level,
          parentId: testCase.parentId,
        });

        expect(result.valid).toBe(testCase.shouldBeValid);
        if (!testCase.shouldBeValid) expect(result.errors.length).toBeGreaterThan(0);
      }
    });

    it('should detect duplicate category names', async () => {
      const categoryName = `${faker.commerce.department()} Duplicate Test`;

      const existingCategory = await categoryService.createCategory({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const result = await categoryService.validateCategoryHierarchy({
        name: categoryName,
        level: 0,
        parentId: null,
      });

      expect(result.valid).toBe(false);
      expect(result.errors).toContain(`Category with name "${categoryName}" already exists`);

      // Test that updating with same name is allowed
      const updateResult = await categoryService.validateCategoryHierarchy({
        name: categoryName,
        level: 0,
        parentId: null,
        _id: existingCategory._id!.toString(),
      });

      expect(updateResult.valid).toBe(true);
      expect(updateResult.errors).toHaveLength(0);

      await Category.deleteOne({ _id: existingCategory._id });
    });
  });
});