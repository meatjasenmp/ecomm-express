import { faker } from '@faker-js/faker';
import Category, { type CategoryInterface } from '../../../app/db/models/Categories.ts';
import Product from '../../../app/db/models/Products.ts';
import categoryService from '../../../app/services/categories/CategoryService.ts';
import { CategoryError } from '../../../app/services/errors/CategoryErrors.ts';

type CategoryWithChildren = CategoryInterface & {
  children?: CategoryWithChildren[];
};

type TestCategoryData = {
  brandName: string;
  categoryName: string;
  subcategoryName: string;
  brandId: string;
  categoryId: string;
  subcategoryId: string;
};

describe('Category Utils', () => {
  let testData: TestCategoryData;

  beforeAll(() => {
    faker.seed(123);
  });

  beforeEach(async () => {
    await Category.deleteMany({
      $or: [{ path: { $regex: /^(brand|category|subcategory)-/i } }, { description: { $regex: /faker/i } }],
    });
  });

  afterEach(async () => {
    if (testData) {
      const idsToDelete = [testData.brandId, testData.categoryId, testData.subcategoryId].filter(
        (id) => id && id.length > 0,
      );

      if (idsToDelete.length > 0) {
        await Category.deleteMany({
          _id: { $in: idsToDelete },
        });
      }
    }
  });

  describe('categoryService.createCategory', () => {
    it('should create a hierarchical category structure', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;
      const subcategoryName = `${faker.commerce.productAdjective()} ${faker.commerce.product()} Subcategory`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      expect(brand).toBeDefined();
      expect(brand.name).toBe(brandName);
      expect(brand.level).toBe(0);
      expect(brand.parentId).toBeNull();
      expect(brand.ancestors).toEqual([]);
      expect(brand.path).toBe(faker.helpers.slugify(brandName.toLowerCase()));

      const category = await categoryService.createCategory({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      expect(category).toBeDefined();
      expect(category.name).toBe(categoryName);
      expect(category.level).toBe(1);
      expect(category.parentId).toBe(brand._id!.toString());
      expect(category.ancestors).toEqual([brand.path]);

      const subcategory = await categoryService.createCategory({
        name: subcategoryName,
        description: `${subcategoryName} generated by faker for testing`,
        level: 2,
        parentId: category._id!.toString(),
        sortOrder: 1,
      });

      expect(subcategory).toBeDefined();
      expect(subcategory.name).toBe(subcategoryName);
      expect(subcategory.level).toBe(2);
      expect(subcategory.parentId).toBe(category._id!.toString());
      expect(subcategory.ancestors).toEqual([brand.path, category.path]);

      testData = {
        brandName,
        categoryName,
        subcategoryName,
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: subcategory._id!.toString(),
      };
    });

    it('should throw error for invalid hierarchy', async () => {
      const brandName = `${faker.company.name()} Brand`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const invalidCategoryName = `${faker.commerce.productName()} Invalid Category`;

      await expect(
        categoryService.createCategory({
          name: invalidCategoryName,
          description: `${invalidCategoryName} - invalid hierarchy test`,
          level: 2,
          parentId: brand._id!.toString(),
          sortOrder: 1,
        }),
      ).rejects.toThrow();

      testData = {
        brandName,
        categoryName: '',
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: '',
        subcategoryId: '',
      };
    });
  });

  describe('categoryService.getCategoryAncestors', () => {
    it('should return ancestors in correct order', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;
      const subcategoryName = `${faker.commerce.productAdjective()} ${faker.commerce.product()} Subcategory`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await categoryService.createCategory({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      const subcategory = await categoryService.createCategory({
        name: subcategoryName,
        description: `${subcategoryName} generated by faker for testing`,
        level: 2,
        parentId: category._id!.toString(),
        sortOrder: 1,
      });

      const ancestors = await categoryService.getCategoryAncestors(subcategory._id!.toString());

      expect(ancestors).toHaveLength(2);
      expect(ancestors[0].name).toBe(brandName);
      expect(ancestors[0].level).toBe(0);
      expect(ancestors[1].name).toBe(categoryName);
      expect(ancestors[1].level).toBe(1);

      testData = {
        brandName,
        categoryName,
        subcategoryName,
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: subcategory._id!.toString(),
      };
    });

    it('should return empty array for root category', async () => {
      const brandName = `${faker.company.name()} Brand`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const ancestors = await categoryService.getCategoryAncestors(brand._id!.toString());
      expect(ancestors).toHaveLength(0);

      testData = {
        brandName,
        categoryName: '',
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: '',
        subcategoryId: '',
      };
    });

    it('should throw error for invalid category ID', async () => {
      await expect(categoryService.getCategoryAncestors('invalid-id')).rejects.toThrow(CategoryError);
      await expect(categoryService.getCategoryAncestors('507f1f77bcf86cd799439011')).rejects.toThrow(CategoryError);
    });
  });

  describe('categoryService.getCategoryDescendants', () => {
    it('should return descendants in correct order', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;
      const subcategoryName = `${faker.commerce.productAdjective()} ${faker.commerce.product()} Subcategory`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await categoryService.createCategory({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      const subcategory = await categoryService.createCategory({
        name: subcategoryName,
        description: `${subcategoryName} generated by faker for testing`,
        level: 2,
        parentId: category._id!.toString(),
        sortOrder: 1,
      });

      const descendants = await categoryService.getCategoryDescendants(brand._id!.toString());

      expect(descendants).toHaveLength(2);
      expect(descendants[0].name).toBe(categoryName);
      expect(descendants[0].level).toBe(1);
      expect(descendants[1].name).toBe(subcategoryName);
      expect(descendants[1].level).toBe(2);

      testData = {
        brandName,
        categoryName,
        subcategoryName,
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: subcategory._id!.toString(),
      };
    });

    it('should throw error for invalid category ID', async () => {
      await expect(categoryService.getCategoryDescendants('invalid-id')).rejects.toThrow(CategoryError);
      await expect(categoryService.getCategoryDescendants('507f1f77bcf86cd799439011')).rejects.toThrow(CategoryError);
    });
  });

  describe('categoryService.getCategoryTree', () => {
    it('should build proper category tree structure', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;
      const subcategoryName = `${faker.commerce.productAdjective()} ${faker.commerce.product()} Subcategory`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await categoryService.createCategory({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      const subcategory = await categoryService.createCategory({
        name: subcategoryName,
        description: `${subcategoryName} generated by faker for testing`,
        level: 2,
        parentId: category._id!.toString(),
        sortOrder: 1,
      });

      const tree = (await categoryService.getCategoryTree(0)) as CategoryWithChildren[];

      const testBrandNode = tree.find((node) => node.name === brandName);
      expect(testBrandNode).toBeDefined();
      expect(testBrandNode!.children).toBeDefined();
      expect(testBrandNode!.children).toHaveLength(1);

      const testCategoryNode = testBrandNode!.children![0];
      expect(testCategoryNode.name).toBe(categoryName);
      expect(testCategoryNode.children).toHaveLength(1);

      const testSubcategoryNode = testCategoryNode.children![0];
      expect(testSubcategoryNode.name).toBe(subcategoryName);
      expect(testSubcategoryNode.children).toHaveLength(0);

      testData = {
        brandName,
        categoryName,
        subcategoryName,
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: subcategory._id!.toString(),
      };
    });
  });

  describe('categoryService.validateCategoryHierarchy', () => {
    it('should validate correct hierarchy', async () => {
      const brandName = `${faker.company.name()} Brand`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const validCategoryName = `${faker.commerce.productName()} Valid Category`;
      const result = await categoryService.validateCategoryHierarchy({
        name: validCategoryName,
        level: 1,
        parentId: brand._id!.toString(),
      });

      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);

      testData = {
        brandName,
        categoryName: '',
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: '',
        subcategoryId: '',
      };
    });

    it('should reject invalid hierarchy', async () => {
      const brandName = `${faker.company.name()} Brand`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const invalidCategoryName = `${faker.commerce.productName()} Invalid Category`;
      const result = await categoryService.validateCategoryHierarchy({
        name: invalidCategoryName,
        level: 2,
        parentId: brand._id!.toString(),
      });


      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors[0]).toContain('Parent level (0) must be exactly one level below child level (2)');

      testData = {
        brandName,
        categoryName: '',
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: '',
        subcategoryId: '',
      };
    });

    it('should validate level constraints', async () => {
      const testCases: Array<{ level: number; parentId: string | null; shouldBeValid: boolean }> = [
        { level: -1, parentId: null, shouldBeValid: false },
        { level: 3, parentId: null, shouldBeValid: false },
        { level: 0, parentId: 'some-id', shouldBeValid: false },
        { level: 1, parentId: null, shouldBeValid: false },
      ];

      for (const testCase of testCases) {
        const categoryName = `${faker.commerce.productName()} Test Category`;
        const result = await categoryService.validateCategoryHierarchy({
          name: categoryName,
          level: testCase.level,
          parentId: testCase.parentId,
        });

        expect(result.valid).toBe(testCase.shouldBeValid);
        if (!testCase.shouldBeValid) expect(result.errors.length).toBeGreaterThan(0);
      }
    });
  });

  describe('categoryService.deleteCategory', () => {
    it('should soft delete a category', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;
      
      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await categoryService.createCategory({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      await categoryService.deleteCategory(category._id!.toString());
      const categories = await categoryService.getCategories({ level: 1 });
      const deletedCategoryExists = categories.data.some((cat) => cat._id?.toString() === category._id?.toString());
      expect(deletedCategoryExists).toBe(false);

      const deletedCategory = await Category.findById(category._id);
      expect(deletedCategory).toBeDefined();
      expect(deletedCategory?.deletedAt).toBeDefined();
      expect(deletedCategory?.deletedAt).toBeInstanceOf(Date);

      testData = {
        brandName,
        categoryName,
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: '',
      };
    });

    it('should prevent deletion of category with subcategories', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;
      const subcategoryName = `${faker.commerce.product()} Subcategory`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await categoryService.createCategory({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      const subcategory = await categoryService.createCategory({
        name: subcategoryName,
        description: `${subcategoryName} generated by faker for testing`,
        level: 2,
        parentId: category._id!.toString(),
        sortOrder: 1,
      });

      await expect(categoryService.deleteCategory(category._id!.toString()))
        .rejects.toThrow('Cannot delete category with subcategories');

      testData = {
        brandName,
        categoryName,
        subcategoryName,
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: subcategory._id!.toString(),
      };
    });

    it('should prevent deletion of category with products', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await categoryService.createCategory({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      const product = await Product.create({
        title: faker.commerce.productName(),
        description: faker.commerce.productDescription(),
        shortDescription: faker.commerce.productAdjective(),
        price: parseFloat(faker.commerce.price()),
        categories: [category._id],
        images: [],
        isPublished: true,
      });

      await expect(categoryService.deleteCategory(category._id!.toString()))
        .rejects.toThrow('Cannot delete category. 1 products are using this category.');

      await Product.deleteOne({ _id: product._id });

      testData = {
        brandName,
        categoryName,
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: '',
      };
    });

    it('should throw error for invalid category ID', async () => {
      await expect(categoryService.deleteCategory('invalid-id')).rejects.toThrow(CategoryError);
      await expect(categoryService.deleteCategory('507f1f77bcf86cd799439011')).rejects.toThrow(CategoryError);
    });
  });

  describe('categoryService.restoreCategory', () => {
    it('should restore a soft deleted category', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;
      
      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await categoryService.createCategory({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      await categoryService.deleteCategory(category._id!.toString());
      const deletedCategories = await categoryService.getCategories({ level: 1 });
      const isDeleted = !deletedCategories.data.some((cat) => cat._id?.toString() === category._id?.toString());
      expect(isDeleted).toBe(true);

      const restoredCategory = await categoryService.restoreCategory(category._id!.toString());
      expect(restoredCategory).toBeDefined();
      expect(restoredCategory._id?.toString()).toBe(category._id?.toString());
      expect(restoredCategory.deletedAt).toBeNull();

      const restoredCategories = await categoryService.getCategories({ level: 1 });
      const isRestored = restoredCategories.data.some((cat) => cat._id?.toString() === category._id?.toString());
      expect(isRestored).toBe(true);

      testData = {
        brandName,
        categoryName,
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: '',
      };
    });

    it('should throw error when restoring non-deleted category', async () => {
      const brandName = `${faker.company.name()} Brand`;
      
      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      await expect(categoryService.restoreCategory(brand._id!.toString()))
        .rejects.toThrow('Category not found or not deleted');

      testData = {
        brandName,
        categoryName: '',
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: '',
        subcategoryId: '',
      };
    });

    it('should throw error for invalid category ID', async () => {
      await expect(categoryService.restoreCategory('invalid-id')).rejects.toThrow(CategoryError);
    });
  });

  describe('categoryService.getCategories', () => {
    it('should return paginated results', async () => {
      const categories: CategoryInterface[] = [];
      for (let i = 0; i < 3; i++) {
        const brandName = `${faker.company.name()} Brand ${i}`;
        const brand = await categoryService.createCategory({
          name: brandName,
          description: `${brandName} generated by faker for testing`,
          level: 0,
          parentId: null,
          sortOrder: i,
        });
        categories.push(brand);
      }

      const result = await categoryService.getCategories({
        page: 1,
        limit: 2,
        level: 0,
      });

      expect(result.data.length).toBeLessThanOrEqual(2);
      expect(result.total).toBeGreaterThanOrEqual(3);
      expect(result.page).toBe(1);
      expect(result.totalPages).toBeGreaterThanOrEqual(2);

      await Category.deleteMany({
        _id: { $in: categories.map((c) => c._id) },
      });
    });

    it('should filter by level', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;

      const brand = await categoryService.createCategory({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await categoryService.createCategory({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      const level0Result = await categoryService.getCategories({ level: 0 });
      const testBrandExists = level0Result.data.some((cat) => cat.name === brandName);
      const testCategoryExists = level0Result.data.some((cat) => cat.name === categoryName);

      expect(testBrandExists).toBe(true);
      expect(testCategoryExists).toBe(false);

      const level1Result = await categoryService.getCategories({ level: 1 });
      const level1BrandExists = level1Result.data.some((cat) => cat.name === brandName);
      const level1CategoryExists = level1Result.data.some((cat) => cat.name === categoryName);

      expect(level1BrandExists).toBe(false);
      expect(level1CategoryExists).toBe(true);

      testData = {
        brandName,
        categoryName,
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: '',
      };
    });
  });
});
