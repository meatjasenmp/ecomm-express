import { faker } from '@faker-js/faker';
import Category from '../../../app/db/models/Categories.js';

describe('Category Model', () => {
  beforeAll(() => {
    faker.seed(456);
  });

  beforeEach(async () => {
    await Category.deleteMany({
      $or: [
        { description: { $regex: /faker for testing/i } },
        { path: { $regex: /^test-/ } }
      ]
    });
  });

  it('should create hierarchical categories', async () => {
    const brandName = `${faker.company.name()} Test Brand`;
    const brandSlug = `test-${faker.helpers.slugify(brandName.toLowerCase())}`;

    const brand = new Category({
      name: brandName,
      description: `${brandName} generated by faker for testing`,
      parentId: null,
      level: 0,
      path: brandSlug,
      isActive: true,
      sortOrder: 1,
    });
    const savedBrand = await brand.save();

    expect(savedBrand.name).toBe(brandName);
    expect(savedBrand.level).toBe(0);
    expect(savedBrand.parentId).toBeNull();
    expect(savedBrand.path).toBe(brandSlug);
    expect(savedBrand.isActive).toBe(true);

    const categoryName = `${faker.commerce.department()} Test Category`;
    const categorySlug = `test-${faker.helpers.slugify(categoryName.toLowerCase())}`;

    const category = new Category({
      name: categoryName,
      description: `${categoryName} generated by faker for testing`,
      parentId: savedBrand._id.toString(),
      level: 1,
      path: `${brandSlug}/${categorySlug}`,
      isActive: true,
      sortOrder: 1,
    });
    const savedCategory = await category.save();

    expect(savedCategory.name).toBe(categoryName);
    expect(savedCategory.level).toBe(1);
    expect(savedCategory.parentId).toBe(savedBrand._id.toString());
    expect(savedCategory.path).toBe(`${brandSlug}/${categorySlug}`);

    const subcategoryName = `${faker.commerce.productAdjective()} ${faker.commerce.product()} Test Subcategory`;
    const subcategorySlug = `test-${faker.helpers.slugify(subcategoryName.toLowerCase())}`;

    const subcategory = new Category({
      name: subcategoryName,
      description: `${subcategoryName} generated by faker for testing`,
      parentId: savedCategory._id.toString(),
      level: 2,
      path: `${brandSlug}/${categorySlug}/${subcategorySlug}`,
      isActive: true,
      sortOrder: 1,
    });
    const savedSubcategory = await subcategory.save();

    expect(savedSubcategory.name).toBe(subcategoryName);
    expect(savedSubcategory.level).toBe(2);
    expect(savedSubcategory.parentId).toBe(savedCategory._id.toString());
    expect(savedSubcategory.path).toBe(`${brandSlug}/${categorySlug}/${subcategorySlug}`);

    await Category.deleteMany({
      _id: { $in: [savedBrand._id, savedCategory._id, savedSubcategory._id] }
    });
  });

  it('should query categories by hierarchy', async () => {
    const brandName = `${faker.company.name()} Test Brand`;
    const categoryName = `${faker.commerce.department()} Test Category`;
    const subcategoryName = `${faker.commerce.productAdjective()} ${faker.commerce.product()} Test Subcategory`;

    const brand = await Category.create({
      name: brandName,
      description: `${brandName} generated by faker for testing`,
      parentId: null,
      level: 0,
      path: `test-${faker.helpers.slugify(brandName.toLowerCase())}`,
      isActive: true,
      sortOrder: 1,
    });

    const category = await Category.create({
      name: categoryName,
      description: `${categoryName} generated by faker for testing`,
      parentId: brand._id.toString(),
      level: 1,
      path: `${brand.path}/test-${faker.helpers.slugify(categoryName.toLowerCase())}`,
      isActive: true,
      sortOrder: 1,
    });

    const subcategory = await Category.create({
      name: subcategoryName,
      description: `${subcategoryName} generated by faker for testing`,
      parentId: category._id.toString(),
      level: 2,
      path: `${category.path}/test-${faker.helpers.slugify(subcategoryName.toLowerCase())}`,
      isActive: true,
      sortOrder: 1,
    });

    const allCategories = await Category.find({
      _id: { $in: [brand._id, category._id, subcategory._id] },
    }).sort({ level: 1, sortOrder: 1 });

    expect(allCategories).toHaveLength(3);
    expect(allCategories[0].level).toBe(0);
    expect(allCategories[1].level).toBe(1);
    expect(allCategories[2].level).toBe(2);

    await Category.deleteMany({
      _id: { $in: [brand._id, category._id, subcategory._id] }
    });
  });

  it('should validate level constraints', async () => {
    const invalidName = `${faker.commerce.productName()} Invalid Level`;
    const invalidSlug = `test-${faker.helpers.slugify(invalidName.toLowerCase())}`;

    const invalidCategory = new Category({
      name: invalidName,
      description: `${invalidName} - This should fail validation`,
      parentId: null,
      level: 5,
      path: invalidSlug,
      isActive: true,
      sortOrder: 1,
    });

    await expect(invalidCategory.save()).rejects.toThrow();
  });

  it('should require unique paths', async () => {
    const categoryName = `${faker.commerce.productName()} Unique Path Test`;
    const categorySlug = `test-${faker.helpers.slugify(categoryName.toLowerCase())}`;

    const category1 = await Category.create({
      name: categoryName,
      description: `${categoryName} generated by faker for testing`,
      parentId: null,
      level: 0,
      path: categorySlug,
      isActive: true,
      sortOrder: 1,
    });

    const category2 = new Category({
      name: `${categoryName} Duplicate`,
      description: `${categoryName} duplicate path test`,
      parentId: null,
      level: 0,
      path: categorySlug,
      isActive: true,
      sortOrder: 2,
    });

    await expect(category2.save()).rejects.toThrow();

    await Category.deleteOne({ _id: category1._id });
  });

  it('should have default values', async () => {
    const categoryName = `${faker.commerce.productName()} Default Values Test`;
    
    const category = new Category({
      name: categoryName,
      description: `${categoryName} default values test`,
      level: 0,
      path: `test-${faker.helpers.slugify(categoryName.toLowerCase())}`,
    });
    const savedCategory = await category.save();

    expect(savedCategory.parentId).toBeNull();
    expect(savedCategory.isActive).toBe(true);
    expect(savedCategory.sortOrder).toBe(0);
    expect(savedCategory.ancestors).toEqual([]);
    expect(savedCategory.createdAt).toBeDefined();
    expect(savedCategory.updatedAt).toBeDefined();

    await Category.deleteOne({ _id: savedCategory._id });
  });
});