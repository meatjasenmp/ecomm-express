import request from 'supertest';
import express from 'express';
import { faker } from '@faker-js/faker';
import Category, { type CategoryInterface } from '../../../app/db/models/Categories.ts';
import Product from '../../../app/db/models/Products.ts';
import categoryRoutes from '../../../app/routes/admin.categories.ts';

type PaginatedCategoryResponse = {
  data: CategoryInterface[];
  total: number;
  page: number;
  totalPages: number;
};

const app = express();
app.use(express.json());
app.use(categoryRoutes);

describe('GET /categories', () => {
  beforeAll(() => {
    faker.seed(123);
  });

  beforeEach(async () => {
    await Category.deleteMany({
      $or: [{ path: { $regex: /^(brand|category|subcategory)-/i } }, { description: { $regex: /faker/i } }],
    });
    await Product.deleteMany({ description: { $regex: /faker/i } });
  });

  afterEach(async () => {
    await Category.deleteMany({
      $or: [{ path: { $regex: /^(brand|category|subcategory)-/i } }, { description: { $regex: /faker/i } }],
    });
    await Product.deleteMany({ description: { $regex: /faker/i } });
  });

  it('should return paginated categories', async () => {
    const brandName = `${faker.company.name()} Brand`;

    await Category.create({
      name: brandName,
      description: `${brandName} generated by faker for testing`,
      level: 0,
      parentId: null,
      path: brandName
        .toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^a-z0-9-]/g, ''),
      ancestors: [],
      sortOrder: 1,
      isActive: true,
    });

    const response = await request(app).get('/categories').query({ page: 1, limit: 10 }).expect(200);
    const body = response.body as PaginatedCategoryResponse;

    expect(body).toHaveProperty('data');
    expect(body).toHaveProperty('total');
    expect(body).toHaveProperty('page', 1);
    expect(body).toHaveProperty('totalPages');
    expect(Array.isArray(body.data)).toBe(true);
    expect(body.data.length).toBeGreaterThan(0);
  });

  it('should filter categories by level', async () => {
    const brandName = `${faker.company.name()} Brand`;
    const categoryName = `${faker.commerce.department()} Category`;

    const brand = await Category.create({
      name: brandName,
      description: `${brandName} generated by faker for testing`,
      level: 0,
      parentId: null,
      path: brandName
        .toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^a-z0-9-]/g, ''),
      ancestors: [],
      sortOrder: 1,
      isActive: true,
    });

    await Category.create({
      name: categoryName,
      description: `${categoryName} generated by faker for testing`,
      level: 1,
      parentId: brand._id.toString(),
      path: `${brand.path}/${categoryName
        .toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^a-z0-9-]/g, '')}`,
      ancestors: [brand.path],
      sortOrder: 1,
      isActive: true,
    });

    const level0Response = await request(app).get('/categories').query({ level: 0 }).expect(200);
    const level0Body = level0Response.body as PaginatedCategoryResponse;

    const level1Response = await request(app).get('/categories').query({ level: 1 }).expect(200);
    const level1Body = level1Response.body as PaginatedCategoryResponse;

    expect(level0Body.data.every((cat: CategoryInterface) => cat.level === 0)).toBe(true);
    expect(level1Body.data.every((cat: CategoryInterface) => cat.level === 1)).toBe(true);
  });

  it('should filter categories by isActive status', async () => {
    const activeBrandName = `${faker.company.name()} Active Brand`;
    const inactiveBrandName = `${faker.company.name()} Inactive Brand`;

    await Category.create({
      name: activeBrandName,
      description: `${activeBrandName} generated by faker for testing`,
      level: 0,
      parentId: null,
      path: activeBrandName
        .toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^a-z0-9-]/g, ''),
      ancestors: [],
      sortOrder: 1,
      isActive: true,
    });

    await Category.create({
      name: inactiveBrandName,
      description: `${inactiveBrandName} generated by faker for testing`,
      level: 0,
      parentId: null,
      path: inactiveBrandName
        .toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^a-z0-9-]/g, ''),
      ancestors: [],
      sortOrder: 2,
      isActive: false,
    });

    const activeResponse = await request(app).get('/categories').query({ isActive: true }).expect(200);
    const activeBody = activeResponse.body as PaginatedCategoryResponse;

    const inactiveResponse = await request(app).get('/categories').query({ isActive: false }).expect(200);
    const inactiveBody = inactiveResponse.body as PaginatedCategoryResponse;

    expect(activeBody.data.every((cat: CategoryInterface) => cat.isActive)).toBe(true);
    expect(inactiveBody.data.every((cat: CategoryInterface) => !cat.isActive)).toBe(true);
  });

  it('should search categories by text', async () => {
    const uniqueSearchTerm = 'unique-test-term';
    const brandName = `${uniqueSearchTerm} ${faker.company.name()} Brand`;

    await Category.create({
      name: brandName,
      description: `${brandName} generated by faker for testing`,
      level: 0,
      parentId: null,
      path: brandName
        .toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^a-z0-9-]/g, ''),
      ancestors: [],
      sortOrder: 1,
      isActive: true,
    });

    await Category.create({
      name: 'Different Brand',
      description: 'Different brand generated by faker for testing',
      level: 0,
      parentId: null,
      path: 'different-brand',
      ancestors: [],
      sortOrder: 2,
      isActive: true,
    });

    const searchResponse = await request(app).get('/categories').query({ search: uniqueSearchTerm }).expect(200);
    const searchBody = searchResponse.body as PaginatedCategoryResponse;

    expect(searchBody.data.length).toBeGreaterThan(0);
    expect(searchBody.data.some((cat: CategoryInterface) => cat.name.includes(uniqueSearchTerm))).toBe(true);
  });

  it('should return 400 for invalid query parameters', async () => {
    await request(app).get('/categories').query({ page: 'invalid' }).expect(400);

    await request(app).get('/categories').query({ limit: -1 }).expect(400);

    await request(app).get('/categories').query({ level: 5 }).expect(400);
  });

  it('should not return soft-deleted categories', async () => {
    const brandName = `${faker.company.name()} Brand`;

    const brand = await Category.create({
      name: brandName,
      description: `${brandName} generated by faker for testing`,
      level: 0,
      parentId: null,
      path: brandName
        .toLowerCase()
        .replace(/\s+/g, '-')
        .replace(/[^a-z0-9-]/g, ''),
      ancestors: [],
      sortOrder: 1,
      isActive: true,
    });

    await Category.updateOne({ _id: brand._id }, { $set: { deletedAt: new Date() } });

    const response = await request(app).get('/categories').expect(200);
    const body = response.body as PaginatedCategoryResponse;

    const deletedCategoryExists = body.data.some((cat: CategoryInterface) => cat._id?.toString() === brand._id?.toString());
    expect(deletedCategoryExists).toBe(false);
  });
});
