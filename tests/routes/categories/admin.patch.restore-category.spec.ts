import request from 'supertest';
import express from 'express';
import { faker } from '@faker-js/faker';
import { createSlug } from '../../../app/helpers/slugify.ts';
import Category, { type CategoryInterface } from '../../../app/db/models/Categories.ts';
import Product from '../../../app/db/models/Products.ts';
import categoryRoutes from '../../../app/routes/admin.categories.ts';

const app = express();
app.use(express.json());
app.use(categoryRoutes);

describe('PATCH /restore-category/:id', () => {
  beforeAll(() => {
    faker.seed(123);
  });

  beforeEach(async () => {
    await Category.deleteMany({
      $or: [{ path: { $regex: /^(brand|category|subcategory)-/i } }, { description: { $regex: /faker/i } }],
    });
    await Product.deleteMany({ description: { $regex: /faker/i } });
  });

  afterEach(async () => {
    await Category.deleteMany({
      $or: [{ path: { $regex: /^(brand|category|subcategory)-/i } }, { description: { $regex: /faker/i } }],
    });
    await Product.deleteMany({ description: { $regex: /faker/i } });
  });

  it('should restore a soft-deleted category successfully', async () => {
    const brandName = `${faker.company.name()} Brand ${Date.now()}`;

    const category = await Category.create({
      name: brandName,
      description: `${brandName} generated by faker for testing`,
      level: 0,
      parentId: null,
      path: createSlug(brandName),
      ancestors: [],
      sortOrder: 1,
      isActive: true,
      deletedAt: new Date(),
    });

    const response = await request(app)
      .patch(`/restore-category/${category._id}`)
      .expect(200);

    expect(response.body.message).toBe('Category restored successfully');
    expect(response.body.category).toBeDefined();

    const restoredCategory = response.body.category as CategoryInterface;
    expect(restoredCategory.name).toBe(brandName);
    expect(restoredCategory.deletedAt).toBeNull();
    expect(restoredCategory._id?.toString()).toBe(category._id?.toString());
    expect(restoredCategory.path).toBe(createSlug(brandName));

    const categoryInDb = await Category.findById(category._id);
    expect(categoryInDb?.deletedAt).toBeNull();
  });

  it('should return 400 for invalid category ID', async () => {
    await request(app)
      .patch('/restore-category/invalid-id')
      .expect(400);
  });

  it('should return 400 for non-existent category', async () => {
    await request(app)
      .patch('/restore-category/507f1f77bcf86cd799439011')
      .expect(400);
  });

  it('should return 400 for category that is not deleted', async () => {
    const brandName = `${faker.company.name()} Brand ${Date.now()}`;

    const category = await Category.create({
      name: brandName,
      description: `${brandName} generated by faker for testing`,
      level: 0,
      parentId: null,
      path: createSlug(brandName),
      ancestors: [],
      sortOrder: 1,
      isActive: true,
    });

    await request(app)
      .patch(`/restore-category/${category._id}`)
      .expect(400);
  });

  it('should restore category and make it available in normal queries', async () => {
    const brandName = `${faker.company.name()} Brand ${Date.now()}`;

    const category = await Category.create({
      name: brandName,
      description: `${brandName} generated by faker for testing`,
      level: 0,
      parentId: null,
      path: createSlug(brandName),
      ancestors: [],
      sortOrder: 1,
      isActive: true,
      deletedAt: new Date(),
    });

    const beforeRestore = await Category.find({ deletedAt: null });
    const beforeRestoreCategory = beforeRestore.find(cat => cat._id?.toString() === category._id?.toString());
    expect(beforeRestoreCategory).toBeUndefined();

    await request(app)
      .patch(`/restore-category/${category._id}`)
      .expect(200);

    const afterRestore = await Category.find({ deletedAt: null });
    const afterRestoreCategory = afterRestore.find(cat => cat._id?.toString() === category._id?.toString());
    expect(afterRestoreCategory).toBeDefined();
    expect(afterRestoreCategory?.name).toBe(brandName);
    expect(afterRestoreCategory?.path).toBe(createSlug(brandName));
  });

  it('should restore level 1 category with proper hierarchy', async () => {
    const brandName = `${faker.company.name()} Brand ${Date.now()}`;
    const categoryName = `${faker.commerce.department()} Category ${Date.now()}`;

    const brand = await Category.create({
      name: brandName,
      description: `${brandName} generated by faker for testing`,
      level: 0,
      parentId: null,
      path: createSlug(brandName),
      ancestors: [],
      sortOrder: 1,
      isActive: true,
    });

    const category = await Category.create({
      name: categoryName,
      description: `${categoryName} generated by faker for testing`,
      level: 1,
      parentId: brand._id?.toString(),
      path: `${brand.path}/${createSlug(categoryName)}`,
      ancestors: [brand.path],
      sortOrder: 1,
      isActive: true,
      deletedAt: new Date(),
    });

    const response = await request(app)
      .patch(`/restore-category/${category._id}`)
      .expect(200);

    const restoredCategory = response.body.category as CategoryInterface;
    expect(restoredCategory.name).toBe(categoryName);
    expect(restoredCategory.level).toBe(1);
    expect(restoredCategory.parentId).toBe(brand._id?.toString());
    expect(restoredCategory.ancestors).toEqual([brand.path]);
    expect(restoredCategory.path).toBe(`${brand.path}/${createSlug(categoryName)}`);
    expect(restoredCategory.deletedAt).toBeNull();
  });

  it('should restore level 2 category with proper hierarchy', async () => {
    const brandName = `${faker.company.name()} Brand ${Date.now()}`;
    const categoryName = `${faker.commerce.department()} Category ${Date.now()}`;
    const subcategoryName = `${faker.commerce.product()} Subcategory ${Date.now()}`;

    const brand = await Category.create({
      name: brandName,
      description: `${brandName} generated by faker for testing`,
      level: 0,
      parentId: null,
      path: createSlug(brandName),
      ancestors: [],
      sortOrder: 1,
      isActive: true,
    });

    const category = await Category.create({
      name: categoryName,
      description: `${categoryName} generated by faker for testing`,
      level: 1,
      parentId: brand._id?.toString(),
      path: `${brand.path}/${createSlug(categoryName)}`,
      ancestors: [brand.path],
      sortOrder: 1,
      isActive: true,
    });

    const subcategory = await Category.create({
      name: subcategoryName,
      description: `${subcategoryName} generated by faker for testing`,
      level: 2,
      parentId: category._id?.toString(),
      path: `${category.path}/${createSlug(subcategoryName)}`,
      ancestors: [brand.path, category.path],
      sortOrder: 1,
      isActive: true,
      deletedAt: new Date(),
    });

    const response = await request(app)
      .patch(`/restore-category/${subcategory._id}`)
      .expect(200);

    const restoredSubcategory = response.body.category as CategoryInterface;
    expect(restoredSubcategory.name).toBe(subcategoryName);
    expect(restoredSubcategory.level).toBe(2);
    expect(restoredSubcategory.parentId).toBe(category._id?.toString());
    expect(restoredSubcategory.ancestors).toEqual([brand.path, category.path]);
    expect(restoredSubcategory.path).toBe(`${category.path}/${createSlug(subcategoryName)}`);
    expect(restoredSubcategory.deletedAt).toBeNull();
  });

  it('should preserve all category properties when restoring', async () => {
    const brandName = `${faker.company.name()} Brand ${Date.now()}`;

    const category = await Category.create({
      name: brandName,
      description: `${brandName} generated by faker for testing`,
      level: 0,
      parentId: null,
      path: createSlug(brandName),
      ancestors: [],
      sortOrder: 5,
      isActive: false,
      deletedAt: new Date(),
    });

    const response = await request(app)
      .patch(`/restore-category/${category._id}`)
      .expect(200);

    const restoredCategory = response.body.category as CategoryInterface;
    expect(restoredCategory.name).toBe(brandName);
    expect(restoredCategory.description).toBe(`${brandName} generated by faker for testing`);
    expect(restoredCategory.level).toBe(0);
    expect(restoredCategory.sortOrder).toBe(5);
    expect(restoredCategory.isActive).toBe(false);
    expect(restoredCategory.path).toBe(createSlug(brandName));
    expect(restoredCategory.deletedAt).toBeNull();
  });
});