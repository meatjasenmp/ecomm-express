import { faker } from '@faker-js/faker';
import Category, { type CategoryInterface } from '../../app/db/models/Categories.js';
import {
  createCategoryWithHierarchy,
  buildCategoryTree,
  getCategoryAncestors,
  getCategoryDescendants,
  getCategoriesPaginated,
  validateCategoryHierarchy,
  createSlug,
  CategoryError,
} from '../../app/helpers/category-utils.js';

type CategoryWithChildren = CategoryInterface & {
  children?: CategoryWithChildren[];
};

type TestCategoryData = {
  brandName: string;
  categoryName: string;
  subcategoryName: string;
  brandId: string;
  categoryId: string;
  subcategoryId: string;
};

describe('Category Utils', () => {
  let testData: TestCategoryData;

  beforeAll(() => {
    faker.seed(123);
  });

  beforeEach(async () => {
    await Category.deleteMany({
      $or: [{ path: { $regex: /^(brand|category|subcategory)-/i } }, { description: { $regex: /faker/i } }],
    });
  });

  afterEach(async () => {
    if (testData) {
      const idsToDelete = [testData.brandId, testData.categoryId, testData.subcategoryId].filter(
        (id) => id && id.length > 0,
      );

      if (idsToDelete.length > 0) {
        await Category.deleteMany({
          _id: { $in: idsToDelete },
        });
      }
    }
  });

  describe('createCategoryWithHierarchy', () => {
    it('should create a hierarchical category structure', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;
      const subcategoryName = `${faker.commerce.productAdjective()} ${faker.commerce.product()} Subcategory`;

      const brand = await createCategoryWithHierarchy({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      expect(brand).toBeDefined();
      expect(brand.name).toBe(brandName);
      expect(brand.level).toBe(0);
      expect(brand.parentId).toBeNull();
      expect(brand.ancestors).toEqual([]);
      expect(brand.path).toBe(createSlug(brandName));

      const category = await createCategoryWithHierarchy({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      expect(category).toBeDefined();
      expect(category.name).toBe(categoryName);
      expect(category.level).toBe(1);
      expect(category.parentId).toBe(brand._id!.toString());
      expect(category.ancestors).toEqual([brand.path]);

      const subcategory = await createCategoryWithHierarchy({
        name: subcategoryName,
        description: `${subcategoryName} generated by faker for testing`,
        level: 2,
        parentId: category._id!.toString(),
        sortOrder: 1,
      });

      expect(subcategory).toBeDefined();
      expect(subcategory.name).toBe(subcategoryName);
      expect(subcategory.level).toBe(2);
      expect(subcategory.parentId).toBe(category._id!.toString());
      expect(subcategory.ancestors).toEqual([brand.path, category.path]);

      testData = {
        brandName,
        categoryName,
        subcategoryName,
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: subcategory._id!.toString(),
      };
    });

    it('should throw error for invalid hierarchy', async () => {
      const brandName = `${faker.company.name()} Brand`;

      const brand = await createCategoryWithHierarchy({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const invalidCategoryName = `${faker.commerce.productName()} Invalid Category`;

      await expect(
        createCategoryWithHierarchy({
          name: invalidCategoryName,
          description: `${invalidCategoryName} - invalid hierarchy test`,
          level: 2,
          parentId: brand._id!.toString(),
          sortOrder: 1,
        }),
      ).rejects.toThrow();

      testData = {
        brandName,
        categoryName: '',
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: '',
        subcategoryId: '',
      };
    });
  });

  describe('createSlug', () => {
    it('should create proper slugs from category names', () => {
      const testCases: Array<{ input: string; expected: string }> = [
        { input: '  Multiple   Spaces  ', expected: 'multiple-spaces' },
        { input: 'Hello World!', expected: 'hello-world' },
      ];

      testCases.forEach(({ input, expected }) => {
        expect(createSlug(input)).toBe(expected);
      });

      const dynamicName = `${faker.company.name()} Air Max`;
      expect(createSlug(dynamicName)).toBeDefined();
      expect(typeof createSlug(dynamicName)).toBe('string');
      expect(createSlug(dynamicName).length).toBeGreaterThan(0);
    });

    it('should throw error for empty names', () => {
      expect(() => createSlug('')).toThrow(CategoryError);
      expect(() => createSlug('   ')).toThrow(CategoryError);
    });
  });

  describe('getCategoryAncestors', () => {
    it('should return ancestors in correct order', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;
      const subcategoryName = `${faker.commerce.productAdjective()} ${faker.commerce.product()} Subcategory`;

      const brand = await createCategoryWithHierarchy({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await createCategoryWithHierarchy({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      const subcategory = await createCategoryWithHierarchy({
        name: subcategoryName,
        description: `${subcategoryName} generated by faker for testing`,
        level: 2,
        parentId: category._id!.toString(),
        sortOrder: 1,
      });

      const ancestors = await getCategoryAncestors(subcategory._id!.toString());

      expect(ancestors).toHaveLength(2);
      expect(ancestors[0].name).toBe(brandName);
      expect(ancestors[0].level).toBe(0);
      expect(ancestors[1].name).toBe(categoryName);
      expect(ancestors[1].level).toBe(1);

      testData = {
        brandName,
        categoryName,
        subcategoryName,
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: subcategory._id!.toString(),
      };
    });

    it('should return empty array for root category', async () => {
      const brandName = `${faker.company.name()} Brand`;

      const brand = await createCategoryWithHierarchy({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const ancestors = await getCategoryAncestors(brand._id!.toString());
      expect(ancestors).toHaveLength(0);

      testData = {
        brandName,
        categoryName: '',
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: '',
        subcategoryId: '',
      };
    });

    it('should throw error for invalid category ID', async () => {
      await expect(getCategoryAncestors('invalid-id')).rejects.toThrow(CategoryError);
      await expect(getCategoryAncestors('507f1f77bcf86cd799439011')).rejects.toThrow(CategoryError);
    });
  });

  describe('getCategoryDescendants', () => {
    it('should return descendants in correct order', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;
      const subcategoryName = `${faker.commerce.productAdjective()} ${faker.commerce.product()} Subcategory`;

      const brand = await createCategoryWithHierarchy({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await createCategoryWithHierarchy({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      const subcategory = await createCategoryWithHierarchy({
        name: subcategoryName,
        description: `${subcategoryName} generated by faker for testing`,
        level: 2,
        parentId: category._id!.toString(),
        sortOrder: 1,
      });

      const descendants = await getCategoryDescendants(brand._id!.toString());

      expect(descendants).toHaveLength(2);
      expect(descendants[0].name).toBe(categoryName);
      expect(descendants[0].level).toBe(1);
      expect(descendants[1].name).toBe(subcategoryName);
      expect(descendants[1].level).toBe(2);

      testData = {
        brandName,
        categoryName,
        subcategoryName,
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: subcategory._id!.toString(),
      };
    });

    it('should throw error for invalid category ID', async () => {
      await expect(getCategoryDescendants('invalid-id')).rejects.toThrow(CategoryError);
      await expect(getCategoryDescendants('507f1f77bcf86cd799439011')).rejects.toThrow(CategoryError);
    });
  });

  describe('buildCategoryTree', () => {
    it('should build proper category tree structure', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;
      const subcategoryName = `${faker.commerce.productAdjective()} ${faker.commerce.product()} Subcategory`;

      const brand = await createCategoryWithHierarchy({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await createCategoryWithHierarchy({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      const subcategory = await createCategoryWithHierarchy({
        name: subcategoryName,
        description: `${subcategoryName} generated by faker for testing`,
        level: 2,
        parentId: category._id!.toString(),
        sortOrder: 1,
      });

      const tree = (await buildCategoryTree(0)) as CategoryWithChildren[];

      const testBrandNode = tree.find((node) => node.name === brandName);
      expect(testBrandNode).toBeDefined();
      expect(testBrandNode!.children).toBeDefined();
      expect(testBrandNode!.children).toHaveLength(1);

      const testCategoryNode = testBrandNode!.children![0];
      expect(testCategoryNode.name).toBe(categoryName);
      expect(testCategoryNode.children).toHaveLength(1);

      const testSubcategoryNode = testCategoryNode.children![0];
      expect(testSubcategoryNode.name).toBe(subcategoryName);
      expect(testSubcategoryNode.children).toHaveLength(0);

      testData = {
        brandName,
        categoryName,
        subcategoryName,
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: subcategory._id!.toString(),
      };
    });
  });

  describe('validateCategoryHierarchy', () => {
    it('should validate correct hierarchy', async () => {
      const brandName = `${faker.company.name()} Brand`;

      const brand = await createCategoryWithHierarchy({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const validCategoryName = `${faker.commerce.productName()} Valid Category`;
      const result = await validateCategoryHierarchy({
        name: validCategoryName,
        level: 1,
        parentId: brand._id!.toString(),
      });

      expect(result.valid).toBe(true);
      expect(result.errors).toHaveLength(0);

      testData = {
        brandName,
        categoryName: '',
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: '',
        subcategoryId: '',
      };
    });

    it('should reject invalid hierarchy', async () => {
      const brandName = `${faker.company.name()} Brand`;

      const brand = await createCategoryWithHierarchy({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const invalidCategoryName = `${faker.commerce.productName()} Invalid Category`;
      const result = await validateCategoryHierarchy({
        name: invalidCategoryName,
        level: 2,
        parentId: brand._id!.toString(),
      });

      expect(result.valid).toBe(false);
      expect(result.errors.length).toBeGreaterThan(0);
      expect(result.errors[0]).toContain('Parent level (0) must be exactly one level below child level (2)');

      testData = {
        brandName,
        categoryName: '',
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: '',
        subcategoryId: '',
      };
    });

    it('should validate level constraints', async () => {
      const testCases: Array<{ level: number; parentId: string | null; shouldBeValid: boolean }> = [
        { level: -1, parentId: null, shouldBeValid: false },
        { level: 3, parentId: null, shouldBeValid: false },
        { level: 0, parentId: 'some-id', shouldBeValid: false },
        { level: 1, parentId: null, shouldBeValid: false },
      ];

      for (const testCase of testCases) {
        const categoryName = `${faker.commerce.productName()} Test Category`;
        const result = await validateCategoryHierarchy({
          name: categoryName,
          level: testCase.level,
          parentId: testCase.parentId,
        });

        expect(result.valid).toBe(testCase.shouldBeValid);
        if (!testCase.shouldBeValid) expect(result.errors.length).toBeGreaterThan(0);
      }
    });
  });

  describe('getCategoriesPaginated', () => {
    it('should return paginated results', async () => {
      const categories: CategoryInterface[] = [];
      for (let i = 0; i < 3; i++) {
        const brandName = `${faker.company.name()} Brand ${i}`;
        const brand = await createCategoryWithHierarchy({
          name: brandName,
          description: `${brandName} generated by faker for testing`,
          level: 0,
          parentId: null,
          sortOrder: i,
        });
        categories.push(brand);
      }

      const result = await getCategoriesPaginated({
        page: 1,
        limit: 2,
        level: 0,
      });

      expect(result.categories.length).toBeLessThanOrEqual(2);
      expect(result.total).toBeGreaterThanOrEqual(3);
      expect(result.page).toBe(1);
      expect(result.totalPages).toBeGreaterThanOrEqual(2);

      await Category.deleteMany({
        _id: { $in: categories.map((c) => c._id) },
      });
    });

    it('should filter by level', async () => {
      const brandName = `${faker.company.name()} Brand`;
      const categoryName = `${faker.commerce.department()} Category`;

      const brand = await createCategoryWithHierarchy({
        name: brandName,
        description: `${brandName} generated by faker for testing`,
        level: 0,
        parentId: null,
        sortOrder: 1,
      });

      const category = await createCategoryWithHierarchy({
        name: categoryName,
        description: `${categoryName} generated by faker for testing`,
        level: 1,
        parentId: brand._id!.toString(),
        sortOrder: 1,
      });

      const level0Result = await getCategoriesPaginated({ level: 0 });
      const testBrandExists = level0Result.categories.some((cat) => cat.name === brandName);
      const testCategoryExists = level0Result.categories.some((cat) => cat.name === categoryName);

      expect(testBrandExists).toBe(true);
      expect(testCategoryExists).toBe(false);

      const level1Result = await getCategoriesPaginated({ level: 1 });
      const level1BrandExists = level1Result.categories.some((cat) => cat.name === brandName);
      const level1CategoryExists = level1Result.categories.some((cat) => cat.name === categoryName);

      expect(level1BrandExists).toBe(false);
      expect(level1CategoryExists).toBe(true);

      testData = {
        brandName,
        categoryName,
        subcategoryName: '',
        brandId: brand._id!.toString(),
        categoryId: category._id!.toString(),
        subcategoryId: '',
      };
    });
  });
});
